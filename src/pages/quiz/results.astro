---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { requireAuth } from '../../lib/auth';
import { getQuizSession, completeQuizSession } from '../../lib/quiz';
import type { Answers, Question } from '../../types';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '../../types/supabase';
import RatingModal from '../../components/quiz/RatingModal';

// Protection de la route
const authResult = await requireAuth(Astro);

// Si c'est une redirection, elle a dÃ©jÃ  Ã©tÃ© effectuÃ©e
if (authResult instanceof Response) {
  return authResult;
}

const { user, profile } = authResult;

// RÃ©cupÃ©rer l'ID de session
const sessionId = Astro.url.searchParams.get('session');

if (!sessionId) {
  return Astro.redirect('/quiz/setup');
}

// Cast pour accÃ©der Ã  supabase
const supabase = (Astro.locals as { supabase?: SupabaseClient<Database> }).supabase;
if (!supabase) {
  return Astro.redirect('/quiz/setup');
}

// Charger la session
const session = await getQuizSession(supabase, sessionId);

if (!session) {
  return Astro.redirect('/quiz/setup');
}

// VÃ©rifier que la session appartient Ã  l'utilisateur
if (session.user_id !== user.id) {
  return Astro.redirect('/quiz/setup');
}

// Si pas encore terminÃ©e, marquer comme complÃ©tÃ©e
if (!session.completed_at) {
  await completeQuizSession(supabase, sessionId);
}

// Charger les questions pour afficher les dÃ©tails
// âš ï¸ Pour le mode custom-quiz, les questions n'existent pas en DB (IDs temporaires)
let questions: Question[] | null = null;

if (session.quiz_type !== 'ai-custom-quiz') {
  const { data: questionsData } = await supabase
    .from('questions')
    .select('*')
    .in('id', session.questions_ids);
  
  // Convertir les donnÃ©es Supabase (Json) en Question[] (string[])
  if (questionsData) {
    questions = questionsData.map((q) => ({
      ...q,
      choices: Array.isArray(q.choices) ? q.choices as string[] : [],
    })) as Question[];
  }
}

// Calculer les stats
const totalQuestions = session.questions_ids.length;
const answers = (session.answers as Answers) || [];
const answeredQuestions = answers.filter((a) => a !== null && a !== undefined).length;

// Calculer les correctAnswers
let correctAnswers = 0;

if (session.quiz_type === 'ai-custom-quiz') {
  // Pour les quiz custom, utiliser les temp_questions stockÃ©es dans la session
  const tempQuestions = (session as any).temp_questions as Array<{ correct_index: number }> | null;
  
  if (tempQuestions && Array.isArray(tempQuestions)) {
    correctAnswers = answers.reduce((count: number, answer: number | null, index: number) => {
      if (answer === null || answer === undefined) return count;
      const question = tempQuestions[index];
      return question && answer === question.correct_index ? count + 1 : count;
    }, 0);
  } else {
    // Fallback si temp_questions n'est pas disponible : utiliser le nombre de rÃ©ponses non-nulles
    // qui ont potentiellement Ã©tÃ© correctes (approximation basÃ©e sur score)
    // 20 pts max par question (10 base + 10 bonus temps)
    correctAnswers = Math.min(
      Math.round(session.score / 15), // Moyenne entre 10 et 20
      answeredQuestions
    );
  }
} else {
  // Pour les quiz normaux, vÃ©rifier chaque rÃ©ponse
  // On s'assure que toutes les questions sont chargÃ©es avant de calculer
  if (questions && questions.length === session.questions_ids.length) {
    correctAnswers = answers.reduce((count: number, answer: number | null, index: number) => {
      if (answer === null || answer === undefined) return count;
      const questionId = session.questions_ids[index];
      const question = questions.find((q: Question) => q.id === questionId);
      // Si la question n'est pas trouvÃ©e, on ne la compte pas (ne devrait pas arriver)
      if (!question) {
        console.warn(`Question ${questionId} not found for index ${index}`);
        return count;
      }
      if (answer === question.correct_index) {
        return count + 1;
      }
      return count;
    }, 0);
  } else {
    // Fallback : si les questions ne sont pas toutes chargÃ©es, utiliser le score comme estimation
    console.warn('Not all questions loaded, using score estimation');
    correctAnswers = Math.round(session.score / 15);
  }
}

const incorrectAnswers = answeredQuestions - correctAnswers;
const accuracy = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
const finalScore = Math.round(session.score * 100) / 100;

// DÃ©terminer le rank basÃ© sur le score
let rank = 'ğŸ¥‰ Bronze';
let rankClass = 'bronze';
if (accuracy >= 90) {
  rank = 'ğŸ† LÃ©gende';
  rankClass = 'legend';
} else if (accuracy >= 75) {
  rank = 'ğŸ¥‡ Or';
  rankClass = 'gold';
} else if (accuracy >= 50) {
  rank = 'ğŸ¥ˆ Argent';
  rankClass = 'silver';
}
---

<BaseLayout title="RÃ©sultats du Quiz - Qivana">
  <div class="quiz-results">
    <div class="quiz-results__container">
      {/* Header avec rank */}
      <div class={`quiz-results__header quiz-results__header--${rankClass}`}>
        <div class="quiz-results__rank">{rank}</div>
        <h1 class="quiz-results__title">Quiz TerminÃ© !</h1>
        <p class="quiz-results__subtitle">
          {session.universe.toUpperCase()} â€¢ {session.difficulty === 'easy' ? 'Facile' : session.difficulty === 'medium' ? 'Moyen' : 'Difficile'}
        </p>
      </div>

      {/* Score principal */}
      <div class="quiz-results__score-card">
        <div class="quiz-results__score-value">{finalScore}</div>
        <div class="quiz-results__score-label">Points totaux</div>
      </div>

      {/* Stats grid */}
      <div class="quiz-results__stats">
        <div class="stat-card stat-card--success">
          <div class="stat-card__icon">âœ“</div>
          <div class="stat-card__value">{correctAnswers}</div>
          <div class="stat-card__label">Bonnes rÃ©ponses</div>
        </div>

        <div class="stat-card stat-card--danger">
          <div class="stat-card__icon">âœ—</div>
          <div class="stat-card__value">{incorrectAnswers}</div>
          <div class="stat-card__label">Mauvaises rÃ©ponses</div>
        </div>
      </div>

      {/* Messages motivants */}
      <div class="quiz-results__message">
        {accuracy >= 90 && (
          <p>ğŸ”¥ Incroyable ! Tu es un vÃ©ritable expert de {session.universe} !</p>
        )}
        {accuracy >= 75 && accuracy < 90 && (
          <p>ğŸ‘ Excellent travail ! Continue comme Ã§a !</p>
        )}
        {accuracy >= 50 && accuracy < 75 && (
          <p>ğŸ’ª Pas mal ! Encore un peu de pratique et ce sera parfait !</p>
        )}
        {accuracy < 50 && (
          <p>ğŸ˜Š Bon dÃ©but ! Recommence pour amÃ©liorer ton score !</p>
        )}
      </div>

      {/* Actions */}
      <div class="quiz-results__actions">
        <a href={session.quiz_type === 'ai-custom-quiz' ? '/quiz/custom-quiz' : '/quiz/setup'} class="btn btn--primary btn--large">
          Nouveau Quiz ğŸš€
        </a>
        <a href="/profile" class="btn btn--secondary btn--large">
          Mon Profil
        </a>
      </div>

      {/* Share (optionnel pour plus tard) */}
      <div class="quiz-results__share">
        <p class="quiz-results__share-label">Partage ton score !</p>
        <div class="quiz-results__share-buttons">
          <button class="share-btn share-btn--twitter" disabled>
            ğŸ¦ Twitter
          </button>
          <button class="share-btn share-btn--discord" disabled>
            ğŸ’¬ Discord
          </button>
        </div>
        <p class="quiz-results__share-note">(BientÃ´t disponible)</p>
      </div>
    </div>
  </div>

  {/* Modal de notation - s'affiche aprÃ¨s 2 secondes */}
  <RatingModal 
    client:only="react"
    sessionId={sessionId}
    quizType={session.quiz_type as 'db' | 'ai-predefined' | 'ai-custom-quiz' | 'duel'}
    theme={session.universe}
    promptUsed={(session as any).prompt_used}
  />
</BaseLayout>

<style lang="scss">
@use '../../styles/pages/quiz' as *;
</style>

<script>
  // âš ï¸ PROTECTION : EmpÃªcher de revenir en arriÃ¨re sur un quiz terminÃ©
  if (typeof window !== 'undefined') {
    // Remplacer l'entrÃ©e dans l'historique pour que le bouton "retour" ne revienne pas sur le quiz
    // On ajoute une nouvelle entrÃ©e dans l'historique pour la page de rÃ©sultats
    // Cela empÃªche le bouton "retour" de revenir sur la page de quiz
    window.history.pushState(null, '', window.location.href);
    
    // Ã‰couter les Ã©vÃ©nements de navigation (popstate = bouton retour)
    window.addEventListener('popstate', (event) => {
      // Si l'utilisateur essaie de revenir en arriÃ¨re depuis la page de rÃ©sultats,
      // rediriger vers la page de setup au lieu de permettre le retour sur le quiz
      window.location.href = '/quiz/setup';
    });
  }
</script>
