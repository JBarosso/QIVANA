---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { requireAuth } from '../../lib/auth';

// Protection de la route - Authentification requise (tous les plans peuvent voir leurs r√©sultats)
const authResult = await requireAuth(Astro);

// Si c'est une redirection, elle a d√©j√† √©t√© effectu√©e
if (authResult instanceof Response) {
  return authResult;
}

const { user, profile } = authResult;

// R√©cup√©rer le salon depuis l'URL
const salonId = Astro.url.searchParams.get('salon');
let salon = null;

// R√©cup√©rer supabase
const supabase = (Astro.locals as { supabase?: any }).supabase;

if (salonId && supabase) {
  // R√©cup√©rer le salon par ID
  const { data, error } = await supabase
    .from('duel_sessions')
    .select('*')
    .eq('id', salonId)
    .single();

  if (!error && data) {
    salon = data;
  }
}

// Si le salon n'existe pas, rediriger
if (!salon) {
  return Astro.redirect('/duel/create?error=salon-not-found');
}

// V√©rifier que le duel est termin√© OU qu'il y a des r√©sultats dans duel_results
// (car le statut peut ne pas √™tre mis √† jour imm√©diatement, mais les r√©sultats existent)
let hasResults = false;
if (supabase) {
  const { data: duelResult, error: resultError } = await supabase
    .from('duel_results')
    .select('id')
    .eq('room_id', salon.salon_code)
    .limit(1)
    .maybeSingle();
  
  hasResults = !!duelResult && !resultError;
}

// Si le statut n'est pas 'completed' ET qu'il n'y a pas de r√©sultats, rediriger
if (salon.status !== 'completed' && !hasResults) {
  return Astro.redirect(`/duel/play?salon=${salonId}&error=duel-not-completed`);
}

// Si le statut n'est pas 'completed' mais qu'il y a des r√©sultats, mettre √† jour le statut automatiquement
if (salon.status !== 'completed' && hasResults && supabase) {
  await supabase
    .from('duel_sessions')
    .update({
      status: 'completed',
      completed_at: new Date().toISOString(),
    })
    .eq('id', salonId);
  
  // Recharger le salon avec le nouveau statut
  const { data: updatedSalon } = await supabase
    .from('duel_sessions')
    .select('*')
    .eq('id', salonId)
    .single();
  
  if (updatedSalon) {
    salon = updatedSalon;
  }
}

// R√©cup√©rer les r√©sultats du duel depuis duel_results (Socket.IO sauvegarde ici)
let playerScores: Array<{
  userId: string;
  pseudo: string;
  totalScore: number;
  correctAnswers: number;
  totalQuestions: number;
  rank: number;
}> = [];

if (supabase) {
  // R√©cup√©rer les r√©sultats depuis duel_results en utilisant le salon_code
  const { data: duelResult, error: resultError } = await supabase
    .from('duel_results')
    .select('*')
    .eq('room_id', salon.salon_code)
    .order('completed_at', { ascending: false })
    .limit(1)
    .single();

  if (!resultError && duelResult && duelResult.players) {
    // Les r√©sultats sont d√©j√† dans le bon format depuis Socket.IO
    const players = duelResult.players as Array<{
      playerId: string;
      pseudo: string;
      score: number;
      rank: number;
    }>;

    // Les r√©sultats incluent maintenant correctAnswers et totalQuestions
    playerScores = players.map((player) => ({
      userId: player.playerId,
      pseudo: player.pseudo,
      totalScore: player.score,
      correctAnswers: (player as any).correctAnswers || 0,
      totalQuestions: (player as any).totalQuestions || (salon.questions_ids?.length as number | undefined) || 0,
      rank: player.rank,
    }));

    // Trier par score d√©croissant (d√©j√† fait c√¥t√© serveur, mais on s'assure)
    playerScores.sort((a, b) => b.totalScore - a.totalScore);
  } else {
    // Fallback : essayer de r√©cup√©rer depuis duel_answers (ancien syst√®me)
    console.warn('No duel_results found, trying duel_answers fallback');
    const { data: answers, error: answersError } = await supabase
      .from('duel_answers')
      .select('*')
      .eq('duel_session_id', salonId);

    if (!answersError && answers && answers.length > 0) {
      // R√©cup√©rer les pseudos des joueurs
      const participants = Array.isArray(salon.participants) ? salon.participants : [];
      const allPlayerIds = [salon.chef_id, ...participants.map((p: any) => p.id)];

      const { data: profiles } = await supabase
        .from('profiles')
        .select('id, pseudo')
        .in('id', allPlayerIds);

      const profileMap = new Map<string, string>((profiles || []).map((p: { id: string; pseudo: string }) => [p.id, p.pseudo]));

      // Calculer les scores par joueur
      const scoreMap = new Map<string, { score: number; correct: number }>();

      answers.forEach((answer: any) => {
        const userId = answer.user_id;
        if (!scoreMap.has(userId)) {
          scoreMap.set(userId, { score: 0, correct: 0 });
        }
        const playerScore = scoreMap.get(userId)!;
        playerScore.score += answer.points_earned || 0;
        if (answer.is_correct) {
          playerScore.correct += 1;
        }
      });

      // Construire la liste des scores
      playerScores = Array.from(scoreMap.entries()).map(([userId, stats], index) => ({
        userId,
        pseudo: (profileMap.get(userId) as string | undefined) || 'Joueur inconnu',
        totalScore: stats.score,
        correctAnswers: stats.correct,
        totalQuestions: (salon.questions_ids?.length as number | undefined) || 0,
        rank: index + 1,
      }));

      // Trier par score d√©croissant
      playerScores.sort((a, b) => b.totalScore - a.totalScore);
    }
  }
}

// URL de partage
const siteUrl = import.meta.env.PUBLIC_SITE_URL || Astro.url.origin;
const shareUrl = `${siteUrl}/duel/results?salon=${salonId}`;
---

<BaseLayout title="R√©sultats du Duel - Qivana">
  <div class="duel-results">
    <div class="duel-results__container">
      <header class="duel-results__header">
        <h1 class="duel-results__title">{salon.salon_name}</h1>
        <p class="duel-results__subtitle">R√©sultats du duel</p>
      </header>

      <div class="duel-results__content">
        <!-- Classement -->
        <section class="duel-results__ranking">
          <h2 class="duel-results__section-title">Classement</h2>
          <ol class="duel-results__ranking-list">
            {playerScores.length === 0 ? (
              <li class="duel-results__ranking-item duel-results__ranking-item--empty">
                <p class="duel-results__empty-message">
                  Aucun r√©sultat disponible pour ce duel.
                </p>
              </li>
            ) : (
              playerScores.map((player, index) => {
                const isCurrentUser = player.userId === user.id;
                const rank = player.rank || index + 1;
                const isFirst = rank === 1;
              
              return (
                <li
                  class={`duel-results__ranking-item ${isCurrentUser ? 'duel-results__ranking-item--current' : ''} ${isFirst ? 'duel-results__ranking-item--first' : ''}`}
                >
                  <div class="duel-results__ranking-rank">
                    {isFirst ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`}
                  </div>
                  <div class="duel-results__ranking-info">
                    <span class="duel-results__ranking-name">
                      {player.pseudo}
                      {isCurrentUser && <span class="duel-results__ranking-badge">Vous</span>}
                    </span>
                    <span class="duel-results__ranking-stats">
                      {player.correctAnswers} / {player.totalQuestions} correctes
                    </span>
                  </div>
                  <div class="duel-results__ranking-score">
                    {player.totalScore} pts
                  </div>
                </li>
              );
            })
            )}
          </ol>
        </section>

        <!-- Actions -->
        <section class="duel-results__actions">
          <button
            class="btn btn--primary btn--block"
            id="shareResultsBtn"
            data-share-url={shareUrl}
          >
            üì§ Partager les r√©sultats
          </button>
          <a href="/profile" class="btn btn--secondary btn--block">
            Retour au profil
          </a>
        </section>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  @import '../../styles/pages/_duel.scss';

  .duel-results {
    min-height: 100vh;
    padding: var(--space-6) var(--space-4);
    background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-indigo) 100%);
  }

  .duel-results__container {
    max-width: var(--container-lg);
    margin: 0 auto;
  }

  .duel-results__header {
    text-align: center;
    margin-bottom: var(--space-8);
  }

  .duel-results__title {
    font-family: var(--font-secondary);
    font-size: var(--fs-8);
    font-weight: var(--font-weight-bold);
    color: var(--color-text);
    margin-bottom: var(--space-2);
  }

  .duel-results__subtitle {
    font-size: var(--fs-4);
    color: var(--color-text-muted);
  }

  .duel-results__content {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  .duel-results__ranking {
    background: var(--color-surface);
    border-radius: var(--radius-4);
    padding: var(--space-6);
    box-shadow: var(--shadow-md);
  }

  .duel-results__section-title {
    font-family: var(--font-secondary);
    font-size: var(--fs-5);
    font-weight: var(--font-weight-bold);
    color: var(--color-text);
    margin-bottom: var(--space-4);
  }

  .duel-results__ranking-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
  }

  .duel-results__ranking-item {
    display: flex;
    align-items: center;
    gap: var(--space-4);
    padding: var(--space-4);
    background: var(--color-neutral-800);
    border-radius: var(--radius-3);
    transition: all var(--transition-base);

    &--current {
      background: var(--color-primary);
      border: 2px solid var(--color-cyan);
    }

    &--first {
      background: linear-gradient(135deg, var(--color-warning) 0%, #fbbf24 100%);
      border: 2px solid var(--color-warning);
    }
  }

  .duel-results__ranking-rank {
    font-size: var(--fs-5);
    font-weight: var(--font-weight-bold);
    color: var(--color-text);
    min-width: 60px;
    text-align: center;
  }

  .duel-results__ranking-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: var(--space-1);
  }

  .duel-results__ranking-name {
    font-size: var(--fs-4);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text);
    display: flex;
    align-items: center;
    gap: var(--space-2);
  }

  .duel-results__ranking-badge {
    font-size: var(--fs-2);
    padding: var(--space-1) var(--space-2);
    background: var(--color-cyan);
    color: var(--color-neutral-900);
    border-radius: var(--radius-1);
    font-weight: var(--font-weight-bold);
  }

  .duel-results__ranking-stats {
    font-size: var(--fs-2);
    color: var(--color-text-muted);
  }

  .duel-results__ranking-score {
    font-size: var(--fs-5);
    font-weight: var(--font-weight-bold);
    color: var(--color-warning);
  }

  .duel-results__actions {
    text-align: center;
  }
</style>

<script is:inline define:vars={{ shareUrl }}>
  (function() {
    const shareResultsBtn = document.getElementById('shareResultsBtn');
    if (shareResultsBtn) {
      shareResultsBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(shareUrl).then(function() {
          shareResultsBtn.textContent = '‚úÖ Lien copi√© !';
          setTimeout(function() {
            shareResultsBtn.textContent = 'üì§ Partager les r√©sultats';
          }, 2000);
        }).catch(function(error) {
          console.error('Error copying to clipboard:', error);
          shareResultsBtn.textContent = '‚ùå Erreur';
          setTimeout(function() {
            shareResultsBtn.textContent = 'üì§ Partager les r√©sultats';
          }, 2000);
        });
      });
    }
  })();
</script>
