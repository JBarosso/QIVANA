---
// ============================================
// PROFILE PAGE (Protected)
// ============================================

import BaseLayout from '@/layouts/BaseLayout.astro';
import { getUser, getProfile } from '@/lib/auth';
import BadgeGrid from '@/components/badges/BadgeGrid';
import AvatarModalWrapper from '@/components/avatars/AvatarModalWrapper';
import AiUsageGauge from '@/components/profile/AiUsageGauge';
import type { BadgeData } from '@/components/badges/types';

interface AvatarData {
  id: string;
  code: string;
  name: string;
  description: string;
  image_url: string;
  rarity: 'common' | 'rare' | 'epic' | 'legendary';
  unlocked: boolean;
}

// Type assertion pour supabase
const supabase = (Astro.locals as { supabase?: any }).supabase;

// Require authentication
const user = await getUser(supabase);
if (!user) {
  return Astro.redirect('/auth/login');
}

// Fetch user profile with all fields including duel stats
let profile: any = null;
if (supabase) {
  const { data: profileData, error } = await supabase
    .from('profiles')
    .select('*, total_score, duels_played, duels_won, subscription_end_date')
    .eq('id', user.id)
    .single();
  
  if (error || !profileData) {
    return Astro.redirect('/auth/login?error=Profil+introuvable');
  }
  
  profile = profileData;
}

// Fetch streak
let streak = null;
if (supabase) {
  const { data: streakData } = await supabase
    .from('streaks')
    .select('*')
    .eq('user_id', user.id)
    .single();
  streak = streakData;
}

  // Fetch all badges
  let allBadges: BadgeData[] = [];
  let unlockedBadgeIds = new Set<string>();
  if (supabase) {
    // R√©cup√©rer tous les badges
    const { data: badgesData } = await supabase
      .from('badges')
      .select('*')
      .order('rarity', { ascending: false });
    
    if (badgesData) {
      allBadges = badgesData.map((b: any) => ({
        id: b.id,
        code: b.code,
        name: b.name,
        description: b.description,
        icon_url: b.icon_url,
        rarity: b.rarity as BadgeData['rarity'],
        category: b.category as BadgeData['category'],
      }));
    }

    // R√©cup√©rer les badges d√©bloqu√©s par l'utilisateur
    const { data: userBadgesData } = await supabase
      .from('user_badges')
      .select('badge_id, unlocked_at')
      .eq('user_id', user.id);
    
    if (userBadgesData) {
      unlockedBadgeIds = new Set(userBadgesData.map((ub: any) => ub.badge_id));
      // Ajouter unlocked_at aux badges d√©bloqu√©s
      allBadges = allBadges.map(badge => {
        const userBadge = userBadgesData.find((ub: any) => ub.badge_id === badge.id);
        return {
          ...badge,
          unlocked_at: userBadge?.unlocked_at || null,
        };
      });
    }
  }

  // Fetch all avatars and user's unlocked avatars
  let allAvatars: AvatarData[] = [];
  let unlockedAvatarIds = new Set<string>();
  let selectedAvatar: any = null;
  let hasNewAvatars = false;
  let latestUnlockTime: string | null = null;
  
  if (supabase) {
    // R√©cup√©rer tous les avatars
    const { data: avatarsData } = await supabase
      .from('avatars')
      .select('*')
      .order('rarity', { ascending: true });
    
    // R√©cup√©rer les avatars d√©bloqu√©s par l'utilisateur
    const { data: userAvatarsData } = await supabase
      .from('user_avatars')
      .select('avatar_id, unlocked_at')
      .eq('user_id', user.id);
    
    if (userAvatarsData) {
      unlockedAvatarIds = new Set(userAvatarsData.map((ua: any) => ua.avatar_id));
      
      // V√©rifier s'il y a des avatars d√©bloqu√©s r√©cemment (dans les derni√®res 24h)
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
      // R√©cup√©rer le timestamp du dernier avatar d√©bloqu√©
      latestUnlockTime = userAvatarsData
        .map((ua: any) => ua.unlocked_at)
        .filter((d: string) => d)
        .sort()
        .reverse()[0] || null;
      hasNewAvatars = userAvatarsData.some((ua: any) => ua.unlocked_at > oneDayAgo);
    }
    
    if (avatarsData) {
      allAvatars = avatarsData.map((a: any) => ({
        id: a.id,
        code: a.code,
        name: a.name,
        description: a.description,
        image_url: a.image_url,
        rarity: a.rarity as AvatarData['rarity'],
        unlocked: unlockedAvatarIds.has(a.id),
      }));
    }

    // R√©cup√©rer l'avatar s√©lectionn√©
    if (profile.selected_avatar_id) {
      const { data: avatarData } = await supabase
        .from('avatars')
        .select('*')
        .eq('id', profile.selected_avatar_id)
        .single();
      
      if (avatarData) {
        selectedAvatar = avatarData;
      }
    }
  }

  // Fetch quiz count and solo quiz score
  let quizCount = 0;
  let soloQuizScore = 0;
  if (supabase) {
    const { data: quizData, count } = await supabase
      .from('quiz_sessions')
      .select('score', { count: 'exact' })
      .eq('user_id', user.id)
      .not('completed_at', 'is', null);
    
    quizCount = count || 0;
    
    // Calculer le score solo total
    if (quizData) {
      soloQuizScore = quizData.reduce((acc: number, q: any) => acc + (q.score || 0), 0);
    }
  }

  // Fetch duel stats (from profile or default to 0)
  const profileAny = profile as any;
  let duelsPlayed = profileAny.duels_played || 0;
  let duelsWon = profileAny.duels_won || 0;
  let totalScore = profileAny.total_score || 0;
  
  // V√©rifier si l'utilisateur peut voir les stats de duels (Premium/Premium+ seulement)
  const canAccessDuels = profile.plan === 'premium' || profile.plan === 'premium+';
---

<BaseLayout
  title={`${profile.pseudo} - Profile`}
  description="Votre profil Qivana"
>
  <main class="profile-page">
    <div class="container">
      <div class="profile-card">
        <div class="profile-card__header">
          <button 
            class="profile-avatar profile-avatar--clickable"
            id="avatar-trigger"
            aria-label="Changer d'avatar"
          >
            {selectedAvatar ? (
              <img
                src={selectedAvatar.image_url}
                alt={selectedAvatar.name}
                class="profile-avatar__img"
              />
            ) : (
              <div class="profile-avatar__placeholder">
                {profile.pseudo.charAt(0).toUpperCase()}
              </div>
            )}
            {hasNewAvatars && (
              <div class="profile-avatar__badge" id="avatar-badge" data-latest-unlock={latestUnlockTime}>
                <span class="profile-avatar__badge-dot"></span>
              </div>
            )}
            <div class="profile-avatar__overlay">
              <span class="profile-avatar__overlay-icon">‚úèÔ∏è</span>
            </div>
          </button>
          <div class="profile-info">
            <h1 class="profile-info__name">{profile.pseudo}</h1>
            <p class="profile-info__email">{user.email}</p>
            <div class="profile-badge">
              <span class="profile-badge__label">
                {profile.plan === 'freemium' && 'üÜì Freemium'}
                {profile.plan === 'premium' && '‚≠ê Premium'}
                {profile.plan === 'premium+' && 'üíé Premium+'}
              </span>
            </div>
            
            <!-- Bouton abonnement -->
            <div class="profile-subscription">
              {profile.plan === 'freemium' ? (
                <a href="/pricing" class="btn btn--primary btn--sm">
                  üíé Passer Premium
                </a>
              ) : (
                <>
                  {profile.subscription_end_date && (
                    <p class="profile-subscription__notice">
                      ‚è∞ Abonnement valide jusqu'au {new Date(profile.subscription_end_date).toLocaleDateString('fr-FR', {
                        day: 'numeric',
                        month: 'long',
                        year: 'numeric'
                      })}
                    </p>
                  )}
                  <button id="manageSubscription" class="btn btn--outline btn--sm">
                    ‚öôÔ∏è G√©rer mon abonnement
                  </button>
                </>
              )}
            </div>
          </div>
        </div>

        <div class="profile-card__stats">
          {/* Points Solo (quiz) */}
          <div class="stat-card">
            <div class="stat-card__icon">üìä</div>
            <div class="stat-card__value">{Math.round(soloQuizScore)}</div>
            <div class="stat-card__label">Points Solo</div>
          </div>

          {/* Quiz jou√©s */}
          {quizCount > 0 && (
            <div class="stat-card">
              <div class="stat-card__icon">üéØ</div>
              <div class="stat-card__value">{quizCount}</div>
              <div class="stat-card__label">Quiz jou√©s</div>
            </div>
          )}

          {/* Streak - affich√© seulement si existe */}
          {streak && streak.current_streak > 0 && (
            <div class="stat-card stat-card--streak">
              <div class="stat-card__icon stat-card__icon--fire">üî•</div>
              <div class="stat-card__value">{streak.current_streak}</div>
              <div class="stat-card__label">Streak actuel</div>
              {streak.longest_streak > streak.current_streak && (
                <div class="stat-card__subtext">Record: {streak.longest_streak} jours</div>
              )}
            </div>
          )}

          {/* Duels - affich√© seulement pour Premium/Premium+ et si > 0 */}
          {canAccessDuels && duelsPlayed > 0 && (
            <div class="stat-card">
              <div class="stat-card__icon">‚öîÔ∏è</div>
              <div class="stat-card__value">{duelsPlayed}</div>
              <div class="stat-card__label">Duels jou√©s</div>
            </div>
          )}

          {canAccessDuels && duelsWon > 0 && (
            <div class="stat-card">
              <div class="stat-card__icon">üëë</div>
              <div class="stat-card__value">{duelsWon}</div>
              <div class="stat-card__label">Duels gagn√©s</div>
            </div>
          )}

        </div>

        {/* Section Cr√©dits IA - affich√©e seulement pour Premium/Premium+ */}
        {(profile.plan === 'premium' || profile.plan === 'premium+') && (
          <div class="profile-card__ai-credits">
            <AiUsageGauge client:load userId={user.id} />
          </div>
        )}

        <div class="profile-card__actions">
          <a href="/" class="btn btn--secondary">
            <span class="btn__text">Retour √† l'accueil</span>
          </a>
          <a href="/profile/edit" class="btn btn--primary">
            <span class="btn__text">‚úèÔ∏è √âditer le profil</span>
          </a>
          <button 
            class="btn btn--outline" 
            id="share-profile-btn"
            data-url={`${Astro.url.origin}/profile/${profile.slug}`}
          >
            <span class="btn__text">üì§ Partager</span>
          </button>
          <a href="/auth/logout" class="btn btn--outline">
            <span class="btn__text">Se d√©connecter</span>
          </a>
        </div>
      </div>

      <div class="profile-section">
        <h2 class="profile-section__title">Mes badges</h2>
        <BadgeGrid 
          client:load
          badges={JSON.stringify(allBadges)}
          unlockedBadgeIds={JSON.stringify(Array.from(unlockedBadgeIds))}
          showLocked={true}
        />
      </div>

      <div class="profile-section">
        <h2 class="profile-section__title">Informations du compte</h2>
        <div class="info-list">
          <div class="info-item">
            <span class="info-item__label">Inscrit le</span>
            <span class="info-item__value">
              {new Date(profile.created_at).toLocaleDateString('fr-FR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
              })}
            </span>
          </div>
          <div class="info-item">
            <span class="info-item__label">Plan</span>
            <span class="info-item__value capitalize">{profile.plan}</span>
          </div>
          <div class="info-item">
            <span class="info-item__label">Quota AI</span>
            <span class="info-item__value">
              {profile.plan === 'freemium' && '0 quiz AI/mois'}
              {profile.plan === 'premium' && '10 quiz AI/mois'}
              {profile.plan === 'premium+' && 'Illimit√©'}
            </span>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Avatar Modal -->
  <AvatarModalWrapper 
    client:only="react"
    avatars={JSON.stringify(allAvatars)}
    selectedAvatarId={profile.selected_avatar_id}
  />
</BaseLayout>

<script>
  // ============================================
  // AVATAR BADGE - GESTION DE LA PASTILLE "NOUVEAU"
  // ============================================
  const AVATAR_VIEWED_KEY = 'qivana_avatars_last_viewed';
  const avatarBadge = document.getElementById('avatar-badge') as HTMLElement | null;
  
  // V√©rifier si l'utilisateur a d√©j√† vu les avatars r√©cemment
  function checkAvatarBadgeVisibility() {
    if (!avatarBadge) return;
    
    const lastViewed = localStorage.getItem(AVATAR_VIEWED_KEY);
    const latestUnlock = avatarBadge.dataset.latestUnlock;
    
    if (lastViewed && latestUnlock) {
      // Comparer les dates : si l'utilisateur a vu les avatars APR√àS le dernier d√©blocage,
      // alors on cache la pastille
      const lastViewedDate = new Date(lastViewed);
      const latestUnlockDate = new Date(latestUnlock);
      
      if (lastViewedDate >= latestUnlockDate) {
        avatarBadge.style.display = 'none';
      }
    } else if (lastViewed && !latestUnlock) {
      // Pas de date de d√©blocage disponible mais l'utilisateur a d√©j√† vu
      avatarBadge.style.display = 'none';
    }
  }
  
  // Marquer les avatars comme vus quand le modal s'ouvre
  function markAvatarsAsViewed() {
    localStorage.setItem(AVATAR_VIEWED_KEY, new Date().toISOString());
    if (avatarBadge) {
      avatarBadge.style.display = 'none';
    }
  }
  
  // V√©rifier au chargement
  checkAvatarBadgeVisibility();
  
  // Avatar modal toggle
  const avatarTrigger = document.getElementById('avatar-trigger');
  
  if (avatarTrigger) {
    avatarTrigger.addEventListener('click', () => {
      // Marquer les avatars comme vus
      markAvatarsAsViewed();
      
      // Dispatcher un √©v√©nement pour ouvrir le modal React
      const event = new CustomEvent('open-avatar-modal');
      window.dispatchEvent(event);
    });
  }

  // Share profile
  const shareBtn = document.getElementById('share-profile-btn');
  if (shareBtn) {
    shareBtn.addEventListener('click', async () => {
      const url = shareBtn.getAttribute('data-url');
      
      if (navigator.share) {
        try {
          await navigator.share({
            title: 'Mon profil Qivana',
            url: url || window.location.href,
          });
        } catch (err) {
          // User cancelled
        }
      } else {
        // Fallback: copier dans le presse-papier
        try {
          await navigator.clipboard.writeText(url || window.location.href);
          window.dispatchEvent(new CustomEvent('show-toast', { detail: { message: 'Lien copi√© dans le presse-papier !', type: 'success' } }));
        } catch (err) {
          window.dispatchEvent(new CustomEvent('show-toast', { detail: { message: 'Impossible de copier le lien', type: 'error' } }));
        }
      }
    });
  }

  // Manage subscription (Stripe Customer Portal)
  const manageSubscriptionBtn = document.getElementById('manageSubscription');
  if (manageSubscriptionBtn) {
    manageSubscriptionBtn.addEventListener('click', async () => {
      manageSubscriptionBtn.setAttribute('disabled', 'true');
      manageSubscriptionBtn.textContent = 'Chargement...';

      try {
        const response = await fetch('/api/stripe/portal', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        const data = await response.json();

        if (data.url) {
          window.location.href = data.url;
        } else {
          throw new Error(data.error || 'Erreur inconnue');
        }
      } catch (error) {
        console.error('Portal error:', error);
        window.dispatchEvent(new CustomEvent('show-toast', { detail: { message: 'Erreur: ' + (error instanceof Error ? error.message : 'Impossible d\'ouvrir le portail'), type: 'error' } }));
        manageSubscriptionBtn.removeAttribute('disabled');
        manageSubscriptionBtn.textContent = '‚öôÔ∏è G√©rer mon abonnement';
      }
    });
  }

</script>
