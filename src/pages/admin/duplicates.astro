---
// ============================================
// ADMIN - R√âSOLUTION DES DOUBLONS
// ============================================
// Utilise les embeddings pour d√©tecter les questions similaires

import AdminLayout from '@/layouts/AdminLayout.astro';

const supabase = (Astro.locals as { supabase?: any }).supabase;

interface DuplicateGroup {
  question: any;
  similars: Array<{
    question: any;
    similarity: number;
  }>;
}

let duplicateGroups: DuplicateGroup[] = [];
let pendingCount = 0;

if (supabase) {
  // R√©cup√©rer les questions non approuv√©es qui pourraient √™tre des doublons
  const { data: pendingQuestions } = await supabase
    .from('questions')
    .select(`
      *,
      embedding:embeddings (embedding)
    `)
    .eq('is_approved', false)
    .order('created_at', { ascending: false })
    .limit(50);

  pendingCount = pendingQuestions?.length || 0;

  // Pour chaque question en attente, chercher des similaires parmi les approuv√©es
  if (pendingQuestions && pendingQuestions.length > 0) {
    for (const question of pendingQuestions) {
      // On compare les textes directement pour d√©tecter les doublons potentiels
      // (La comparaison par embedding n√©cessiterait une fonction RPC plus complexe)
      const { data: similars } = await supabase
        .from('questions')
        .select('*')
        .eq('is_approved', true)
        .ilike('question', `%${question.question.substring(0, 50)}%`)
        .neq('id', question.id)
        .limit(5);

      if (similars && similars.length > 0) {
        duplicateGroups.push({
          question,
          similars: similars.map((s: any) => ({
            question: s,
            similarity: calculateTextSimilarity(question.question, s.question),
          })).filter((s: any) => s.similarity > 0.5)
            .sort((a: any, b: any) => b.similarity - a.similarity),
        });
      }
    }

    // Filtrer les groupes qui ont des similaires
    duplicateGroups = duplicateGroups.filter(g => g.similars.length > 0);
  }
}

// Fonction simple de similarit√© textuelle (Jaccard)
function calculateTextSimilarity(text1: string, text2: string): number {
  const words1 = new Set(text1.toLowerCase().split(/\s+/));
  const words2 = new Set(text2.toLowerCase().split(/\s+/));
  
  const intersection = new Set([...words1].filter(x => words2.has(x)));
  const union = new Set([...words1, ...words2]);
  
  return intersection.size / union.size;
}

const universeLabels: Record<string, string> = {
  anime: 'Anime',
  manga: 'Manga',
  comics: 'Comics',
  games: 'Jeux',
  movies: 'Films',
  series: 'S√©ries',
  other: 'Autre',
};

const successMessage = Astro.url.searchParams.get('success');
const errorMessage = Astro.url.searchParams.get('error');
---

<AdminLayout title="R√©solution des Doublons" currentPage="duplicates">
  {successMessage && (
    <div class="admin-alert admin-alert--success">
      ‚úÖ {decodeURIComponent(successMessage)}
    </div>
  )}

  {errorMessage && (
    <div class="admin-alert admin-alert--error">
      ‚ùå {decodeURIComponent(errorMessage)}
    </div>
  )}

  <section class="admin-section">
    <div class="admin-section__header">
      <h2 class="admin-section__title">
        üìã Doublons potentiels ({duplicateGroups.length})
      </h2>
      <div class="admin-section__info">
        <a href="/admin/questions?filter=pending" class="admin-link">
          {pendingCount} questions non approuv√©es ‚Üí
        </a>
      </div>
    </div>

    <p class="admin-description">
      Cette page affiche uniquement les questions non approuv√©es qui ressemblent √† des questions d√©j√† existantes dans la base.
      <br /><br />
      <strong>Note :</strong> Si vous voyez "{pendingCount} questions non approuv√©es" mais 0 doublons potentiels, 
      cela signifie que ces questions sont uniques. Vous pouvez les g√©rer depuis la 
      <a href="/admin/questions?filter=pending" class="admin-link">page des questions en attente</a>.
    </p>

    {duplicateGroups.length > 0 ? (
      <div class="duplicates-list">
        {duplicateGroups.map((group) => (
          <div class="duplicate-card">
            <div class="duplicate-card__new">
              <div class="duplicate-card__label">
                <span class="admin-badge admin-badge--warning">‚è≥ Nouvelle (en attente)</span>
              </div>
              <div class="duplicate-card__question">
                <span class="admin-badge admin-badge--primary">
                  {universeLabels[group.question.universe] || group.question.universe}
                </span>
                <p class="duplicate-card__text">{group.question.question}</p>
                <div class="duplicate-card__choices">
                  {(group.question.choices as string[]).map((choice: string, i: number) => (
                    <span class={`duplicate-card__choice ${i === group.question.correct_index ? 'duplicate-card__choice--correct' : ''}`}>
                      {i === group.question.correct_index ? '‚úÖ' : '‚óã'} {choice}
                    </span>
                  ))}
                </div>
              </div>
              <div class="duplicate-card__actions">
                <form method="post" action="/api/admin/questions/toggle-approve" class="admin-inline-form">
                  <input type="hidden" name="id" value={group.question.id} />
                  <input type="hidden" name="approved" value="true" />
                  <button type="submit" class="btn btn--success btn--sm">
                    ‚úÖ Approuver (pas un doublon)
                  </button>
                </form>
                <a href={`/admin/questions/${group.question.id}`} class="btn btn--primary btn--sm">
                  ‚úèÔ∏è √âditer
                </a>
                <form method="post" action="/api/admin/questions/delete" class="admin-inline-form" onsubmit="return confirm('Supprimer cette question ?')">
                  <input type="hidden" name="id" value={group.question.id} />
                  <button type="submit" class="btn btn--danger btn--sm">
                    üóëÔ∏è Supprimer (doublon)
                  </button>
                </form>
              </div>
            </div>

            <div class="duplicate-card__arrow">‚¨áÔ∏è</div>
            <div class="duplicate-card__label duplicate-card__label--similars">
              Questions similaires existantes:
            </div>

            <div class="duplicate-card__similars">
              {group.similars.map((similar) => (
                <div class="similar-item">
                  <div class="similar-item__header">
                    <span class="admin-badge admin-badge--success">‚úÖ Approuv√©e</span>
                    <span class="similar-item__similarity">
                      Similarit√©: {Math.round(similar.similarity * 100)}%
                    </span>
                  </div>
                  <p class="similar-item__text">{similar.question.question}</p>
                  <div class="similar-item__choices">
                    {(similar.question.choices as string[]).map((choice: string, i: number) => (
                      <span class={`duplicate-card__choice ${i === similar.question.correct_index ? 'duplicate-card__choice--correct' : ''}`}>
                        {i === similar.question.correct_index ? '‚úÖ' : '‚óã'} {choice}
                      </span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    ) : (
      <div class="admin-empty">
        <div class="admin-empty__icon">‚ú®</div>
        <p class="admin-empty__text">Aucun doublon potentiel d√©tect√©</p>
        <p class="admin-empty__subtext">
          Toutes les questions en attente semblent uniques.
        </p>
      </div>
    )}
  </section>
</AdminLayout>

